<!DOCTYPE html>
<html>
  <head>
    <style>
      body{ 
        margin: 0;
        font-family: helvetica;
        overflow: hidden;
      }
      path{
        stroke: black;
        stroke-width: 1;
      }
      svg{
        display:block;
      }
      circle{
        fill: white;
      }
      rect{
        fill: black;
      }
      .equation{
        background: none;
        border: none;
        color: white;
        outline: none;
        font-size: inherit;
        position: absolute;
        top: 0;
        width: 100%;
        margin: 0;
        padding: 0;
        padding-left: 10px;
      }
      .toolbar{
        overflow: hidden;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        color: white;
        font-size: 30px;
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
<body>
  <div class="toolbar">
    z = <input class="equation" type="text" value=""/>
  </div>
  <script src="d3.js"></script>
  <script src="math.js"></script>
  <script src="../dz.js"></script>
  <script>
var w = window.innerWidth, h = window.innerHeight
  , math = mathjs()
  , svg = d3.select('body').append('svg').attr({width: w, height: h})
  , max = Math.max(w, h), min = Math.min(w, h), diff = max - min
  , pi = Math.PI
  , ranges = [ [0, max] , [ - diff / 2, max - diff / 2] ]
  , screenX = d3.scale.linear().domain([-1, 1]).range(ranges[w < h ? 1 : 0])
  , screenY = d3.scale.linear().domain([1, -1]).range(ranges[w > h ? 1 : 0])
  , p = dz.projection.perspective()
  , camera = p.camera().focalLength(1)
  , pos = camera.position([0, 0.5, 1.5]).position()
  , n = 20
  , eq = window.location.hash.replace(/^#/,'') || 'x * y'


svg.append('rect').attr({width: w, height: h})

var circles = svg.selectAll('circle').data(dz.points.grid(n, 1, n)).enter()
  .append('circle')

d3.timer(function(t){
  // t = 0
  circles
    .sort(function(a, b){ return p.depth(a) - p.depth(b) })
    .attr({ 
        cx: function(d){ return screenX(p.x(d)) }
      , cy: function(d){ return screenY(p.y(d)) }
      ,  r: function(d){ return p.scale(d) * 4 }
    }).style('opacity', function(d){
      return (p.depth(d) + 2) / 1
    })
  camera.position(dz.matrix().rotateY(t/10000 * pi).multiVector(pos))
})

var drag = d3.behavior.drag()
  .on('drag', function(d, i){
    var dx = d3.event.dx / w * pi * 2
      , dy = d3.event.dy / h * pi * 2
    pos = dz.matrix().rotateX(dy).rotateY(dx).multiVector(pos)
  })

svg.call(drag)

d3.select('.equation').on('keyup', function(){ update(this.value) })
.call(function(selector){ update(selector.node().value = eq) })
  //.on('keydown', function(){ update(this.value) })

function update(eq){
  try{
    circles.data().forEach(function(d){
      var x = d[0], z = d[1], y = d[2]
      d[1] = z = math.eval(eq.replace(/x/g, x).replace(/y/g, y))
    })
    window.location.hash = eq
  }catch(e){
    console.log(e)
  }
}

  </script>
</body>
</html>